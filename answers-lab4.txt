1) The compiler and linker think that kern/mpentry.S should be run above KERNBASE. However, when we run kern/mpentry.S to setup a new application processor, the new processor can only initially acccess memory below 2^16 (since the processor was designed to be backwards compatiable. Thus, we move mpentry.S into a page starting at MPENTRY_PADDR, and indicate to the new processor to run code starting from there. However, upon compile time, the compiler and linker think the code is giong to be run above KERNBASE, and assigns values of function entry points accordingly. Thus, we use MPBOOTPHYS in order to calculate the shifted function entry points so that we can run the copied code from MPENTRY_PADDR. 
2) If the kernel stacks of the different processors are all mapped to the same physical memory or we only had a single kernel stack across all processors, we would face issues of kernel stacks that have data stored from different processes and environments. Essentially, if one processer moves into kernel mode, and sets up the stack in a certain way, and then moves back into user mode (for any reason) before restoring the stack, we have an issue. At this point, another processor could enter the kernel and would inter-leave data onto the stack. Some reasons this would happen are the kernel yielding the env or handling a kernel interrupt that leads to a return the the user environment. 
If every time we went into kernel mode, we were guaranteed that 1) no other CPU is running kernel code, 2) the kernel code would restore the stack into the correct state after finished and 3) the stack code would finish running, then this wouldn't be an issue. The problem is that these three items might not be guaranteed. For example, it is feasible that we might get an interrupt while in kerneld mode that switches to a different environment
3) When we change from one environment to another, the page directory changes by changing the cr3 register. Although we are mapped to a physically different page directory, parts of the each page directory are replicated (or identical) across page directories. Essentially, the the envs array, we have mapped the page directory for different environments to have the same mapping from va to pa. Thus, even when we switch the page directory, we still can access the same enviornment structure that we were referring to prior to the switch.
4) The environment's registers are saved in the trap() function in trap.c. Essentially, when we have a trap, like a systemcall, we setup the stack in such a way that when we call the trap function, the argument to the trap function is a trapframe structure. In trap.c, we save that trapfram structure in the env structure of the current environment. If the systemcall switches environments, it will have the trapframe of the previous enviornment stored. This is important so that when we return to the runnable environment, we can restore the stack as we left it, and continue running from the previous eip. Essentially, it allows us to return back into the environment, and continue running without any issues. 
