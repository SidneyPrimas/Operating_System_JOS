1) The compiler and linker think that kern/mpentry.S should be run above KERNBASE. However, when we run kern/mpentry.S to setup a new application processor, the new processor can only initially acccess memory below 2^16 (since the processor was designed to be backwards compatiable). Thus, we move mpentry.S into a page starting at MPENTRY_PADDR, and indicate to the new processor to run code starting from there. However, upon compile time, the compiler and linker think the code is giong to be run as a virtual address above KERNBASE, and assigns values of function entry points accordingly. Thus, we use MPBOOTPHYS in order to calculate the shifted function entry points so that we can run the copied code from MPENTRY_PADDR. 
2) If the kernel stacks of the different processors are all mapped to the same physical memory or we only had a single kernel stack across all processors, we would face issues of kernel stacks that have data stored from different processes/environments. Essentially, if one processer moves into kernel mode, and sets up the stack in a certain way, and then moves back into user mode (for any reason) before restoring the stack, we have an issue. At this point, another processor could enter the kernel and would inter-leave data onto the stack. Some reasons this would happen are the kernel yielding the env or handling a kernel interrupt that leads to a return to the the user environment. 
If every time we went into kernel mode, we were guaranteed that 1) no other CPU is running kernel code, 2) the kernel code would restore the stack into the correct state after finished and 3) the stack code would finish running, then this wouldn't be an issue. The problem is that these three items might not be guaranteed. For example, it is feasible that we might get an interrupt while in kerneld mode that switches to a different environment
3) When we change from one environment to another, the page directory changes by changing the cr3 register. Although we are mapped to a physically different page directory, parts of the each page directory are replicated (or identical) across page directories. Essentially, the the envs array, we have mapped the page directory for different environments to have the same mapping from va to pa. Thus, even when we switch the page directory, we still can access the same enviornment structure that we were referring to prior to the switch.
4) The environment's registers are saved in the trap() function in trap.c. Essentially, when we have a trap, like a systemcall, we setup the stack (in trapentry.S) in such a way that when we call the trap function, the argument to the trap function is a trapframe structure. In trap.c, we save that trapfram structure in the env structure of the current environment. If the systemcall switches environments, it will have the trapframe of the previous enviornment stored. This is important so that when we return to the runnable environment, we can restore the stack as we left it, and continue running from the previous eip (with the idential registers setup). Essentially, it allows us to return back into the environment, and continue running by restoring it to exactly the same state that it was before the trap/interrupt. 

Challenge Description: 
We implemented an improved scheduling policy to our kernel implementation. We essentially gave each environment a priority level between 0 and 3, where 3 is the highest priority and 0 is the lowest. The scheduler now essentially selects an environment to run with the highest priority level, excluding the previously running environment. If there are no other environments at any priority level, then it re-runs the previously running environment. Of course, this implementation requires that each environment structure has a priority level, which is used for scheduling. We also added a system call that allows user environments to change each other's priority level. We tested the implementation in a user program called priority.c. In this user program, the parent created 10 children, with each child at different priority levels. We then each child do work, which essentially is print out increasing integers. After each printed integer, the child yield allowing another process to take over. Our user-program worked as expected, with all the high priority tasks being executed first. When there are is an environment with a higher priority level than all others, it still switched off with lower priority environments. Furthermore, we made sure that the system call was only allowed to change the priority of it's own environment. Thus, environments need to be cooperative, but we eliminate the possibility of an environment setting all other priority levels to low, except itself. 
