1) The compiler and linker think that kern/mpentry.S should be run above KERNBASE. However, when we run kern/mpentry.S to setup a new application processor, the new processor can only initially acccess memory below 2^16 (since the processor was designed to be backwards compatiable). Thus, we move mpentry.S into a page starting at MPENTRY_PADDR, and indicate to the new processor to run code starting from there. However, upon compile time, the compiler and linker think the code is giong to be run as a virtual address above KERNBASE, and assigns values of function entry points accordingly. Thus, we use MPBOOTPHYS in order to calculate the shifted function entry points so that we can run the copied code from MPENTRY_PADDR. 
2) If the kernel stacks of the different processors are all mapped to the same physical memory or we only had a single kernel stack across all processors, we would face issues of different processors interleaving data on the kernel stack (from different environments). Although only one processor can be active running the kernel, the other processors can run environments in user mode. When there is an interrupt in these environments, they push their data onto the kernel stack within their processor. This is done before the kernel locked is taken. When the kernel lock becomes available, this environment on this process can then make progress with the data from it's kernel stack. If there was only one kernel stack, then the information pushed onto the stack from a trap in a user program would lead to the data interfereing with the stack of the active kernel. Thus, we need different kernel stacks for each CPU. 
3) When we change from one environment to another, the page directory changes by changing the cr3 register. Although we are mapped to a physically different page directory, parts of the each page directory are replicated (or identical) across page directories. Essentially, the the envs array, we have mapped the page directory for different environments to have the same mapping from va to pa. Thus, even when we switch the page directory, we still can access the same enviornment structure that we were referring to prior to the switch.
4) The environment's registers are saved in the trap() function in trap.c. Essentially, when we have a trap, like a systemcall, we setup the stack (in trapentry.S) in such a way that when we call the trap function, the argument to the trap function is a trapframe structure. In trap.c, we save that trapfram structure in the env structure of the current environment. If the systemcall switches environments, it will have the trapframe of the previous enviornment stored. This is important so that when we return to the runnable environment, we can restore the stack as we left it, and continue running from the previous eip (with the idential registers setup). Essentially, it allows us to return back into the environment, and continue running by restoring it to exactly the same state that it was before the trap/interrupt. 

Challenge Description: 
We implemented an improved scheduling policy to our kernel implementation. We essentially gave each environment a priority level between 0 and 3, where 3 is the highest priority and 0 is the lowest. The scheduler now essentially selects an environment to run with the highest priority level, excluding the previously running environment. If there are no other environments at any priority level, then it re-runs the previously running environment. Of course, this implementation requires that each environment structure has a priority level, which is used for scheduling. We also added a system call that allows user environments to change each other's priority level. We tested the implementation in a user program called priority.c. In this user program, the parent created 10 children, with each child at different priority levels. We then each child do work, which essentially is print out increasing integers. After each printed integer, the child yield allowing another process to take over. Our user-program worked as expected, with all the high priority tasks being executed first. When there are is an environment with a higher priority level than all others, it still switched off with lower priority environments. Furthermore, we made sure that the system call was only allowed to change the priority of it's own environment. Thus, environments need to be cooperative, but we eliminate the possibility of an environment setting all other priority levels to low, except itself. 
