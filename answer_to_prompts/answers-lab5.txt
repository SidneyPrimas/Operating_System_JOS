1) Other then altering the eFlags register when creating the FS environment, no additional changes are needed. The reason for this is that whenever we change environments, the environments registers (including the eFlags register) state is saved in the env struct, which is stored within the envs[] array. When we restore this environment in the future, the eFlags register will be restored within the x86 hardware, thus enabling the IO instructions. When non-FS environments are restored, their respective eFlag register is restored, which will revert the privilege level back to IO instructions being disabled. 


Challenge: For the challenge, I added more features to the shell, including background commands and multiple commands per line. For the multiple commands per line, I used the ';' symbol in order to indicate to the shell that the user intends to input multiple commands per line. When the ';' symbol is detected, we indicate in a variable multiple_commands that the current iteration of runcmd should expect 2 sequential exectuions. Then, we goto 'runit' and execute the first command. Before executing runit, we check if this execution sequence was triggered by a ';' symbol. If so, then we return to the 'again' location in the code, and continue to execute further commands from this runcmd. We continue to iterate within this cycle until we reached a termination symbol, and then gracefully exit, returing the child and continuing the main shell loop. 
The background commands was more complicated. When we found the '&' symbol, then we enable the background variable, and jumpt to 'runit'. In 'runit', we check to see if the background variable has been enabled. If so, then we fork the environment so that we have another child and parent. The parent returns to the main shell loop (after some cleanup) through an exit(). The child is the background environment that will execute the desired command. First the child re-directs it's output to a new file (titled /background) using FD1 filedescriptor. This way, the child can run in the background, saves its output to to background file and then return gracefully once completed. Before we exit the child, we wait for the spawn-ed command to return, and then exit (after some clean up). We tested this implementation out with primespipe and primes (since both take a long time to fully execute). For both of these, we could interact with the shell, typing additional commands, while the background command executed. In these cases, the background command finally hits a fault (due to the nature of the programs). 
