Question 1: Within the network server environment, the output() function is called. Output() has an infinite loop that monitors for IPCs indicating a network packet needs to be transmitted. When such an IPC is dedected, output() formats the packet and transmits the packet through a system call to the E1000 driver. The kernel manages the interface to the E1000 through the driver. If the kernel finds out that the transmit ring is full, then it returns a specific error indicating to the output() function in user mode that the transmit ring is full. The output function continues to attempt to send the data until the packet has been successfully transmitted by the E1000 device, upon which the system call returns a success. Finally, upon success, the output function waits for additional data that it needs to transmit through the E1000. 
 
Question 2: The receive implementation is similar to the transmit implementation. With the receive implementation the network server environment calls the input() function. The input function waits to receive data from the E1000 device. And, once the data has been capture, it sends the data back to the client, or the env_id that was passed through the input() function as an argument. The input() function is also an infinite loop. However, it continually polls the E1000 through a system call to a E1000 driver function that checks if the E1000 has received any packets (the receive ring is not empty). If the receive ring is not empty, then the packet is transmitted through the system call back to the input function. And, an IPC is then sent with the data from the network environment to the client environment. The key with sending data back to the client environment with the IPC is to make sure that the page being sent is not concurrently used by the network environment. Essentially, sending an IPC means that two environments will have VA to the same physical address, and thus can create race conditions. So, as soon as page is sent to the client via IPC, the input() function unmaps the sent page and gets another page for future E1000 packets. If the receive ring is empty, then the receive system call to the E1000 driver returns an error indicating that the ring is empty. The input() function then yields to allow other environments to run. When the network environment regains control, it continues to check the receive ring in the E1000 and yield until a packet has been received. A better approach is to use interrupts provided by the E1000. With this approach, the E1000 HW and drivers are configured in order to provide an interrupt when a packet has been received (re-activating the network environment), which eliminates the need to continually to poll the E1000 when waiting for a packet. 

Question 3: The web-page says: "This File came from JOS." And, there is a scrolling text below it that says: "Cheesy Web-Page". 

Question 4: The lab took me at least 26 hours. 

Challenge: For my challenge, I obtained the MAC address directly from the EEPROM of the E1000. In order to do this, I used the EERD register that is memory mapped within our OS. The EERD register allows me to access data on the EEPROM by indicating which EEPROM address I want to read. Essentially, this is an additional driver function that interacts with the E1000. I used this driver function in order to get the MAC address for the filtering within the receive function. I also created a system call that provides access to the address to the user environment. This is used in the lwIP implementation. So, in my final implementation, there is no hard coded mac address. In fact, when you change the MAC address, the entire system still works as expected. 


