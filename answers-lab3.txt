Answers for Lab3: 
1) The purpose of having an individual handler function for each exception and interrupt is so that 1) we can hanndle exceptions differently based on if they have or don't have an error code, 2) we can handle each exception differently within C code, allowing us to for example handle the breakpoint through different logic and 3) we can provide different privilege levels to different exceptions, allowing us to control who has access to call these exceptions. All of these are reasons that routing through different gates and different handlers provides us benefits. 

2) By calling int $14, the user attempts to activate an interrupt that it doesn't have access to (based on the gate definition, the CPL needs to be at a higher privilige level to invoke this exeption). Thus, when this exeption is being handled by the kernel through the idt, the kernel throws a general protection fault, which is what we end up seeing. If int $14 is allowed to be called from a user program by changing the DPL on the IDT entry, then a Page Fault error is thrown instead, which confirms our answer. 

3) The breakpoint test case generates a general protection fault when the descriptor privilege level (DPL) within the entry of the IDT (or gate) is set to 0. In this case, only kernel  code can call the breakpoint trap. If we try to initiate the vector 3 gate from user code (when the CPL is set to 3), then when the hardware routes us through the vector 3 gate, it will trigger a general protection fault. This is exactly the fault that we observe. So, instead of getting to the breakpoint handling, we are instead routed through the general protection gate, and never see the breakpoint interrupt completed. On the other hand, when we set the DPL to 3, the user code can pass through gate 3. Thus, when the user calls int $3, we successfully pass through the IDT and are routed to the appropriate breakpoint handling code. 

4) The key point of this mechanism is to restrict the types of interrupts that the user can call. Certain faults/interrupts/traps are mapped to clearly defined behavior. When the kernel sees these faults/interrupts/traps, it expects that behavior to have occurred, and might run code to handle the situation accordingly. However, if a user can just call these faults/interrupts/traps then users can sends the kernel faults/interrupts/traps that have not occurred. This is an issue for a few reasons, including 1) when the kernel receives faults/interrupts/traps there is no guarantee if they are based on a real event or a user and 2) they could be used by the user to do something malicious. 

Challenge Writeup: 
For this challenge, I impromved the JOS kernel monitor functionality. I added two commands: continue and single_step. After a breakpoint interrupt, the code is routed towards the monitor function, that monitors user input on the command line. At this point, the code that called the int $3 (breakpoint exception) is not making any progress, and won't until we return to this running environment. So, continue essentially returns to this code/environment with run_env, that sets up the stack, cr3, etc and ultimately drops back down into user mode to continue executing code at the last eip. Since I always implemented single step, it's important that the continue functions always sets the trap flag to 0 (to make sure continue disables debugging mode). 
For the single step function, I essentially enabled debugging mode by enabling the trap flag. Essentially, trap flag is a processor implemented option that calls int $1 after each instruction has been run. We need to catch this interrupt and route it to monitor.c as with the breakpoint. This is done with the same machinery as before, including updating the idt and creating corresponding handling functions. With this  machinery being implemented, we then get an interrupt after each instruction is executed that routes us back to monitor. Then, in monitor we can single step again, or continue. Taken together and with print_trapframe, these commands will be very helpful. 
